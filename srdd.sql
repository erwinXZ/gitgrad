-- phpMyAdmin SQL Dump
-- version 4.5.2
-- http://www.phpmyadmin.net
--
-- Servidor: localhost
-- Tiempo de generación: 26-06-2017 a las 16:29:08
-- Versión del servidor: 10.1.13-MariaDB
-- Versión de PHP: 7.0.8

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- Base de datos: `srdd`
--

DELIMITER $$
--
-- Procedimientos
--
CREATE DEFINER=`root`@`localhost` PROCEDURE `docsList` (IN `_id_project` INT)  BEGIN
	IF (SELECT EXISTS (SELECT * FROM Document WHERE id_project=_id_project)) THEN
		SELECT * FROM Document WHERE id_project = _id_project;
    ELSE
		SELECT 0 AS respuesta;
    END IF;
END$$

CREATE DEFINER=`root`@`localhost` PROCEDURE `idStudent` (IN `_id_client` INT)  BEGIN
	    IF ( SELECT EXISTS (SELECT * FROM Client WHERE id=_id_client))THEN
			IF ( SELECT EXISTS (SELECT * FROM Student WHERE id_client = _id_client))THEN 
				SELECT s.id FROM Client c INNER JOIN Student s ON c.id=s.id_client WHERE s.id_client=_id_client;
			ELSE
				SELECT -1 as respuesta;
			END IF;
		ELSE
			SELECT 0 as respuesta;
    END IF;
END$$

CREATE DEFINER=`root`@`localhost` PROCEDURE `insertClient` (IN `_name` VARCHAR(45), IN `_last_name` VARCHAR(75), IN `_email` VARCHAR(55), IN `_password` VARCHAR(45), IN `_cellphone` VARCHAR(13))  BEGIN
	    IF ( SELECT EXISTS (SELECT * FROM Client WHERE email = _email)) THEN 
		SELECT 0 as respuesta;
    ELSE
		INSERT INTO Client (name, last_name, email, password, cellphone) VALUES(_name, _last_name, _email, _password, _cellphone);
		SELECT 1 as respuesta;
    END IF ;   
END$$

CREATE DEFINER=`root`@`localhost` PROCEDURE `insertDocument` (IN `_file` TEXT, IN `_date` DATETIME, IN `_id_project` INT(11))  BEGIN
    IF ( SELECT EXISTS (SELECT * FROM Project WHERE id=_id_project) ) THEN 
  		IF ( SELECT EXISTS (SELECT * FROM Document d INNER JOIN Project p ON p.id=d.id_project WHERE d.id_project=_id_project OR d.file=_file))THEN
        	SELECT 'El documento ya esta registrado';
        ELSE
        	INSERT INTO Documento (file, date, id_project) VALUES(_file, _date, _id_project);
        END IF;
    ELSE
		SELECT 'El Proyecto no esta registrado';
    END IF;
END$$

CREATE DEFINER=`root`@`localhost` PROCEDURE `insertObservation` (IN `_text` TEXT, IN `_textstart` TEXT, IN `_textend` TEXT, IN `_description` TEXT, IN `_npage` VARCHAR(4), IN `_id_teacher` INT, IN `_id_document` INT)  BEGIN
    IF ( SELECT EXISTS (SELECT * FROM Teacher WHERE id=_id_teacher ) ) THEN 
    	IF ( SELECT EXISTS (SELECT * FROM Document WHERE id=_id_document ) ) THEN 
          INSERT INTO Observation (text, textstart, textend, description, date, status, npage, id_teacher, id_document) VALUES (_text, _textstart, _textend, _description, NOW(), DEFAULT, _npage, _id_teacher, _id_document);
        ELSE
        	SELECT 'El documento no existe';
        END IF;
    ELSE
    	SELECT 'El docente no esta registrado';
    END IF ;  
END$$

CREATE DEFINER=`root`@`localhost` PROCEDURE `insertProject` (IN `_name` VARCHAR(75), IN `_modality` VARCHAR(35), IN `_gestion` VARCHAR(25), IN `_cu` VARCHAR(7), IN `_id_teacher` INT)  BEGIN
DECLARE _id_student INT;	
    IF ( SELECT EXISTS (SELECT * FROM Student WHERE cu=_cu)) THEN 
    SET _id_student = (SELECT id FROM Student WHERE cu=_cu);
		IF ( SELECT NOT EXISTS (SELECT * FROM Project WHERE id_student=_id_student AND id_teacher=_id_teacher)) THEN 
			INSERT INTO Project (name, modality, gestion, id_student, id_teacher) VALUES(_name, _modality, _gestion, _id_student, _id_teacher);
			SELECT 1 AS respuesta;
        ELSE
			SELECT 3 AS respuesta;
		END IF;
    ELSE
		SELECT 0 AS respuesta;
    END IF ;   
END$$

CREATE DEFINER=`root`@`localhost` PROCEDURE `insertStudent` (IN `_name` VARCHAR(45), IN `_last_name` VARCHAR(75), IN `_email` VARCHAR(55), IN `_password` VARCHAR(45), IN `_cellphone` VARCHAR(13), IN `_cu` VARCHAR(8), IN `_college_carrer` VARCHAR(75))  BEGIN
DECLARE _id_client INT;
    IF ( SELECT NOT EXISTS (SELECT * FROM Client WHERE email=_email) ) THEN
		IF ( SELECT NOT EXISTS (SELECT * FROM Student WHERE cu=_cu) ) THEN 
        	INSERT INTO Client (name, last_name, email, password, cellphone) VALUES(_name, _last_name, _email, _password, _cellphone);
            SET _id_client = @@identity;
        	INSERT INTO Student(cu, college_carrer, id_client) VALUES(_cu, _college_carrer, _id_client);
			SELECT 1;
		ELSE
			SELECT 2;
		END IF;
    ELSE
		SELECT 0;
    END IF ;
END$$

CREATE DEFINER=`root`@`localhost` PROCEDURE `insertTeacher` (IN `_name` VARCHAR(45), IN `_last_name` VARCHAR(75), IN `_email` VARCHAR(55), IN `_password` VARCHAR(45), IN `_cellphone` VARCHAR(13), IN `_profession` VARCHAR(50))  BEGIN
DECLARE _id_client INT;
    IF ( SELECT NOT EXISTS (SELECT * FROM Client WHERE email=_email) ) THEN 
        	INSERT INTO Client (name, last_name, email, password, cellphone) VALUES(_name, _last_name, _email, _password, _cellphone);
            SET _id_client = @@identity;
        	INSERT INTO Teacher(profession, id_client) VALUES(_profession, _id_client);
			SELECT 1;
    ELSE
		SELECT 0;
    END IF ;
END$$

CREATE DEFINER=`root`@`localhost` PROCEDURE `listarProject` (IN `_id_teacher` INT)  BEGIN

    IF (SELECT EXISTS (SELECT * FROM Project WHERE id_teacher=_id_teacher)) THEN 
		SELECT p.id, p.name as project_name, p.modality, p.gestion, p.hito, p.register_date, c.name AS user_name, c.last_name, s.cu FROM Project p INNER JOIN Student s 
        ON s.id=p.id_student INNER JOIN Client c ON c.id=s.id_client WHERE p.id_teacher=_id_teacher
        ORDER BY p.register_date ASC;
    ELSE
		SELECT 0 AS respuesta;
        END IF ;   
END$$

CREATE DEFINER=`root`@`localhost` PROCEDURE `listarProjectStudent` (IN `_id_student` INT)  BEGIN
    IF (SELECT EXISTS (SELECT * FROM Project WHERE id_student=_id_student)) THEN 
		SELECT id, name as project_name, modality, gestion, hito, register_date FROM Project WHERE id_student=_id_student;
	ELSE
        SELECT 0 AS respuesta;
        END IF ;   
END$$

CREATE DEFINER=`root`@`localhost` PROCEDURE `listProjectStudent` (IN `_id_project` INT)  BEGIN
	IF (SELECT EXISTS (SELECT * FROM Project WHERE id=_id_project)) THEN
		SELECT file FROM Document WHERE id_project=_id_project AND status="r" ORDER BY date DESC
		LIMIT 1;
    ELSE
		SELECT 0;
    END IF;
END$$

CREATE DEFINER=`root`@`localhost` PROCEDURE `readObservation` (IN `id` INT(11))  BEGIN
    IF ( SELECT EXISTS (SELECT * FROM Observation WHERE id_document=id ) ) THEN 
    	SELECT o.id, o.text, o.textstart, o.textend, o.description, o.date, o.status, o.npage, c.name FROM Observation o INNER JOIN Teacher t ON o.id_teacher=t.id  INNER JOIN Client c ON t.id_client=c.id WHERE o.id_document=id;
    ELSE
    	SELECT 0;
    END IF;
END$$

CREATE DEFINER=`root`@`localhost` PROCEDURE `reviewed` (IN `_id_document` INT)  BEGIN
	IF (SELECT EXISTS (SELECT * FROM Document WHERE id=_id_document AND status='p')) THEN 
		UPDATE Document SET status='r' WHERE id=_id_document;
        SELECT 1 AS respuesta;
	ELSE
		SELECT 0 AS respuesta;
    END IF;
END$$

CREATE DEFINER=`root`@`localhost` PROCEDURE `signIn` (IN `_email` VARCHAR(55), IN `_password` VARCHAR(45))  BEGIN
	IF ( SELECT EXISTS (SELECT * FROM Client c INNER JOIN Student s ON c.id=s.id_client WHERE c.email = _email AND c.password=_password))THEN 
		SELECT c.id, c.name, c.last_name, c.email, c.picture, s.id, s.cu, s.college_carrer,1 as rol FROM Client c INNER JOIN Student s ON c.id=s.id_client WHERE email = _email;
	ELSE	
		IF ( SELECT EXISTS (SELECT * FROM Client c INNER JOIN Teacher t ON c.id=t.id_client WHERE c.email = _email AND c.password=_password))THEN 
			SELECT c.id, c.name, c.last_name, c.email, c.picture, t.id, t.profession, 2 as rol FROM Client c INNER JOIN Teacher t ON c.id=t.id_client WHERE email = _email;
		ELSE
			SELECT 0 as respuesta;
        END IF;
    END IF;
    
END$$

CREATE DEFINER=`root`@`localhost` PROCEDURE `signInStudent` (IN `_email` VARCHAR(55), IN `_password` VARCHAR(45))  BEGIN
	IF ( SELECT EXISTS (SELECT * FROM Client WHERE email = _email))THEN 
		SELECT id, name, last_name, email, picture FROM Client WHERE email = _email;
    ELSE
		SELECT 0 as respuesta;
    END IF;
END$$

CREATE DEFINER=`root`@`localhost` PROCEDURE `transfer` (IN `_email_student` VARCHAR(75), IN `_email_teacher` VARCHAR(75), IN `_id_teacher` INT)  BEGIN
DECLARE _id_teacherNew INT; 
DECLARE _id_student INT; 
DECLARE _name VARCHAR(75); 
DECLARE _modality VARCHAR(35); 
DECLARE _gestion VARCHAR(7);
DECLARE _hito VARCHAR(25);
DECLARE _register_date TIMESTAMP;
SET _id_teacherNew = (SELECT t.id FROM Teacher t INNER JOIN Client c ON c.id=t.id_client WHERE c.email=_email_teacher);
SET _id_student = (SELECT s.id FROM Student s INNER JOIN Client c ON c.id=s.id_client WHERE c.email=_email_student);
	IF ( SELECT EXISTS (SELECT * FROM Client c INNER JOIN Teacher t ON c.id=t.id_client WHERE email = _email_teacher))THEN
		IF ( SELECT EXISTS (SELECT * FROM Client WHERE email = _email_student))THEN
            IF (SELECT EXISTS (SELECT * FROM Project WHERE id_student = _id_student))THEN	 
				IF (SELECT NOT EXISTS (SELECT * FROM Project WHERE id_student = _id_student AND id_teacher=_id_teacherNew))THEN
					SET _name = (SELECT name FROM Project WHERE id_teacher=_id_teacher AND id_student = _id_student);
					SET _modality = (SELECT modality FROM Project WHERE id_teacher=_id_teacher AND id_student = _id_student);
					SET _gestion = (SELECT gestion FROM Project WHERE id_teacher=_id_teacher AND id_student = _id_student);
					SET _hito = (SELECT hito FROM Project WHERE id_teacher=_id_teacher AND id_student = _id_student);
					SET _register_date = (SELECT register_date FROM Project WHERE id_teacher=_id_teacher AND id_student = _id_student);
					INSERT INTO Project(name, modality, gestion, hito, register_date, id_student, id_teacher) VALUES(_name, _modality, _gestion, _hito, _register_date, _id_student, _id_teacherNew);
					SELECT 1 AS respuesta;
				ELSE 
					SELECT 4 AS respuesta;
            END IF;
			ELSE
            SELECT 3;
            END IF;
        ELSE
			SELECT 2 AS respuesta;
		END IF;
    ELSE
		SELECT 0 AS respuesta;
    END IF;
END$$

CREATE DEFINER=`root`@`localhost` PROCEDURE `updateObservation` (IN `_text` TEXT, IN `_id_observation` INT)  BEGIN
	IF (SELECT EXISTS (SELECT * FROM Observation WHERE id=_id_observation)) THEN 
		UPDATE Observation SET description=_text WHERE id=_id_observation;
        SELECT 1 AS respuesta;
	ELSE
		SELECT 0 AS respuesta;
	END IF;
END$$

CREATE DEFINER=`root`@`localhost` PROCEDURE `updateObservationStatus` (IN `_status` TEXT, IN `_id_observation` INT)  BEGIN
	IF (SELECT EXISTS (SELECT * FROM Observation WHERE id=_id_observation)) THEN 
		UPDATE Observation SET status = _status WHERE id=_id_observation;
        SELECT 1 AS respuesta;
	ELSE
		SELECT 0 AS respuesta;
	END IF;
END$$

CREATE DEFINER=`root`@`localhost` PROCEDURE `uploadProjectS` (IN `_file` TEXT, IN `_id_project` INT)  BEGIN
	IF (SELECT EXISTS (SELECT * FROM Project WHERE id=_id_project)) THEN 
		INSERT INTO Document(file, id_project) VALUES(_file,_id_project);
		SELECT 1;
    ELSE
		SELECT 0;
    END IF;
END$$

DELIMITER ;

-- --------------------------------------------------------

--
-- Estructura de tabla para la tabla `Client`
--

CREATE TABLE `Client` (
  `id` int(11) NOT NULL,
  `name` varchar(45) COLLATE utf8_spanish_ci DEFAULT NULL,
  `last_name` varchar(75) COLLATE utf8_spanish_ci DEFAULT NULL,
  `email` varchar(55) COLLATE utf8_spanish_ci DEFAULT NULL,
  `password` varchar(45) COLLATE utf8_spanish_ci DEFAULT NULL,
  `cellphone` varchar(13) COLLATE utf8_spanish_ci NOT NULL,
  `picture` varchar(400) COLLATE utf8_spanish_ci DEFAULT 'user.png'
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_spanish_ci;

--
-- Volcado de datos para la tabla `Client`
--

INSERT INTO `Client` (`id`, `name`, `last_name`, `email`, `password`, `cellphone`, `picture`) VALUES
(39, 'Erwin Méndez', 'Mejía', 'erwin@gmail.com', '1234', '78526594', 'user.png'),
(40, 'Kare', 'Vera', 'karen@gmail.com', '1234', '75124589', 'user.png'),
(41, 'Koda', 'Negron', 'kodita@gmail.com', '1234', '79301010', 'user.png'),
(42, 'Gary David', 'Guzman', 'gary@gmail.com', '1234', '60125484', 'user.png'),
(43, 'Soledad', 'Nina', 'sole@gmail.com', '1234', '23652148', 'user.png'),
(44, 'Carla', 'Candia', 'carla@gmail.com', '1234', '75263521', 'user.png'),
(45, 'Jose', 'Chirinos', 'jose@gmail.com', '1234', '7845326', 'user.png');

-- --------------------------------------------------------

--
-- Estructura de tabla para la tabla `Document`
--

CREATE TABLE `Document` (
  `id` int(11) NOT NULL,
  `file` text COLLATE utf8_spanish_ci,
  `status` char(1) COLLATE utf8_spanish_ci NOT NULL DEFAULT 'p',
  `date` datetime DEFAULT CURRENT_TIMESTAMP,
  `id_project` int(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_spanish_ci;

--
-- Volcado de datos para la tabla `Document`
--

INSERT INTO `Document` (`id`, `file`, `status`, `date`, `id_project`) VALUES
(25, '05-06-38-20-06-17-sample.pdf', 'r', '2017-06-20 11:30:38', 5),
(26, '06-06-20-20-06-17-sample.pdf', 'r', '2017-06-20 12:01:20', 5);

-- --------------------------------------------------------

--
-- Estructura de tabla para la tabla `Observation`
--

CREATE TABLE `Observation` (
  `id` int(11) NOT NULL,
  `text` text COLLATE utf8_spanish_ci NOT NULL,
  `textstart` text COLLATE utf8_spanish_ci NOT NULL,
  `textend` text COLLATE utf8_spanish_ci NOT NULL,
  `description` text COLLATE utf8_spanish_ci,
  `date` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT 'Observation',
  `status` char(1) COLLATE utf8_spanish_ci DEFAULT 'p',
  `npage` varchar(4) COLLATE utf8_spanish_ci NOT NULL,
  `id_teacher` int(11) DEFAULT NULL,
  `id_document` int(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_spanish_ci;

--
-- Volcado de datos para la tabla `Observation`
--

INSERT INTO `Observation` (`id`, `text`, `textstart`, `textend`, `description`, `date`, `status`, `npage`, `id_teacher`, `id_document`) VALUES
(1, 'Sistema de diseño de losas', 'Proyecto de grado', '1/2017', '35-3559', '2017-06-19 22:06:54', 't', '123', 21, 1),
(3, 'In TraceMonkey, we support two representations for numbers:integers and doubles. The interpreter uses integer representationsas much as it can, switching for results that can only be representedas doubles. When a trace is started, some values may be importedand represented as integers. Some operations on integers requireguards. For example, adding two integers can produce a value toolarge for the integer representation.', 'In TraceMonkey, we support two representations for numbers:', 'In TraceMonkey, we support two representations for numbers:integers and doubles. The interpreter uses integer representationsas much as it can, switching for results that can only be representedas doubles. When a trace is started, some values may be importedand represented as integers. Some operations on integers requireguards. For example, adding two integers can produce a value toolarge for the integer representation.', 'pollito con papas', '2017-06-19 22:14:07', 'p', '5', 21, 1),
(4, 'La  asignatura  está  orientada  a  mejorar  la  comprensión  de la  Gestión  de  Proyectos  de  Software abordando  actividades  de  gestión  que  están  presentes  en  todo  el  ciclo  de  vida  de  desarrollo.  De esta  manera  se  prepara  al  Ingeniero  de  Sistemas  para  que pueda  liderar  y  gerenciar  proyectos  siguiendo estándares y buenas prácticas de la Ingeniería.', 'La  asignatura  está  orientada  a  mejorar  la  comprensión  de ', 'La  asignatura  está  orientada  a  mejorar  la  comprensión  de la  Gestión  de  Proyectos  de  Software abordando  actividades  de  gestión  que  están  presentes  en  todo  el  ciclo  de  vida  de  desarrollo.  De esta  manera  se  prepara  al  Ingeniero  de  Sistemas  para  que pueda  liderar  y  gerenciar  proyectos  siguiendo estándares y buenas prácticas de la Ingeniería.', 'ADSAsd', '2017-06-20 01:34:22', 'p', '1', 21, 1),
(5, 'Desarrollar  los  conocimientos y  habilidades específicos para  la  gestión  de  riesgos  de  un proyecto de software siguiendo estándares y buenas prácticas.', 'Desarrollar  los  conocimientos ', 'Desarrollar  los  conocimientos y  habilidades específicos para  la  gestión  de  riesgos  de  un proyecto de software siguiendo estándares y buenas prácticas.', 'uihuihui', '2017-06-20 05:49:38', 'p', '2', 21, 1),
(6, 'Trace optimization for dynamic languages.The closest area ofrelated work is on applying trace optimization to type-specializedynamic languages. Existing work shares the idea of generatingtype-specialized code speculatively with guards along interpretertraces.', 'Trace optimization for dynamic languages.', 'Trace optimization for dynamic languages.The closest area ofrelated work is on applying trace optimization to type-specializedynamic languages. Existing work shares the idea of generatingtype-specialized code speculatively with guards along interpretertraces.', 'Nueva Observacion', '2017-06-20 11:04:59', 'p', '12', 21, 1),
(7, 'programs.Categories and Subject DescriptorsD.3.4 [Programming Lan-guages]: Processors —Incremental compilers, code generation.General TermsDesign, Experimentation, Measurement, Perfor-mance.KeywordsJavaScript, just-in-time compilation, trace trees.1.  IntroductionDynamic languagessuch as JavaScript, Python, and Ruby, are pop-ular since they are expressive, accessible to non-experts, and makedeployment as easy as distributing a source file. They are used forsmall scripts as well as for complex applications. JavaScript, forexample, is the de facto standard for client-side web programmingPermission to make digital or hard copies of all or part of this work for personal orclassroom use is granted without fee provided that copies are not made or distributedfor profit or commercial advantage and that copies bear this notice and the full citationon the first page. To copy otherwise, to republish, to post on servers or to redistributeto lists, requires prior specific permission and/or a fee.PLDI’09,June 15–20, 2009, Dublin, Ireland.Copyrightc©2009 ACM 978-1-60558-392-1/09/06. . . $5.00and is used for the application logic of browser-based productivityapplications such as Google Mail, Google Docs and Zimbra Col-laboration Suite. In this domain, in order to provide a fluid userexperience and enable a new generation of applications, virtual ma-chines must provide a low startup time and high performance.Compilers for statically typed languages rely on type informa-tion to generate efficient machine code. In a dynamically typed pro-gramming language such as JavaScript, the types of expressionsmay vary at runtime. This means that the compiler can no longereasily transform operations into machine instructions that operateon one specific type. Without exact type information, the compilermust emit slower generalized machine code that can deal with allpotential type combinations. While compile-time static type infer-ence might be able to gather type information to generate opti-mized machine code, traditional static analysis is very expensiveand hence not well suited for the highly interactive environment ofa web browser.We present a trace-based compilation technique for dynamiclanguages that reconciles speed of compilation with excellent per-formance of the generated machine code. Our system uses a mixed-mode execution approach: the system starts running JavaScript in afast-starting bytecode interpreter. As the program runs, the systemidentifieshot(frequently executed) bytecode sequences, recordsthem, and compiles them to fast native code. We call such a se-quence of instructions atrace.Unlike method-based dynamic compilers, our dynamic com-piler operates at the granularity of individual loops. This designchoice is based on the expectation that programs spend most oftheir time in hot loops. Even in dynamically typed languages, weexpect hot loops to be mostlytype-stable, meaning that the types ofvalues are invariant. (12) For example, we would expect loop coun-ters that start as integers to remain integers for all iterations. Whenboth of these expectations hold, a trace-based compiler can coverthe program execution with a small number of type-specialized, ef-ficiently compiled traces.Each compiled trace covers one path through the program withone mapping of values to types. When the VM executes a compiledtrace, it cannot guarantee that the same path will be followedor that the same types will occur in subsequent loop iterations.Hence, recording and compiling a tracespeculatesthat the path andtyping will be exactly as they were during recording for subsequentiterations of the loop.Every compiled trace contains all theguards(checks) requiredto validate the speculation. If one of the guards fails (if controlflow is different, or a value of a different type is generated), thetrace exits. If an exit becomes hot, the VM can record abranchtracestarting at the exit to cover the new path. In this way, the VMrecords atrace treecovering all the hot paths through the loop.Nested loops can be difficult to optimize for tracing VMs. Ina na ̈ıve implementation, inner loops would become hot first, andthe VM would start tracing there. When the inner loop exits, theVM would detect that a different branch was taken. The VM wouldtry to record a branch trace, and find that the trace reaches not theinner loop header, but the outer loop header. At this point, the VMcould continue tracing until it reaches the inner loop header again,thus tracing the outer loop inside a trace tree for the inner loop.But this requires tracing a copy of the outer loop for every side exitand type combination in the inner loop. In essence, this is a formof unintended tail duplication, which can easily overflow the codecache. Alternatively, the VM could simply stop tracing, and give upon ever tracing outer loops.We solve the nested loop problem by recordingnested tracetrees. Our system traces the inner loop exactly as the na ̈ıve version.The system stops extending the inner tree when it reaches an outerloop, but then it starts a new trace at the outer loop header. Whenthe outer loop reaches the inner loop header, the system tries to callthe trace tree for the inner loop. If the call succeeds, the VM recordsthe call to the inner tree as part of the outer trace and finishesthe outer trace as normal. In this way, our system can trace anynumber of loops nested to any depth without causing excessive tailduplication.These techniques allow a VM to dynamically translate a pro-gram to nested, type-specialized trace trees. Because traces cancross function call boundaries, our techniques also achieve the ef-fects of inlining. Because traces have no internal control-flow joins,they can be optimized in linear time by a simple compiler (10).Thus, our tracing VM efficiently performs the same kind of op-timizations that would require interprocedural analysis in a staticoptimization setting. This makes tracing an attractive and effectivetool to type specialize even complex function call-rich code.We implemented these techniques for an existing JavaScript in-terpreter, SpiderMonkey. We call the resulting tracing VMTrace-Monkey. TraceMonkey supports all the JavaScript features of Spi-derMonkey, with a 2x-20x speedup for traceable programs.This paper makes the following contributions:•We explain an algorithm for dynamically forming trace trees tocover a program, representing nested loops as nested trace trees.•We explain how to speculatively generate efficient type-specializedcode for traces from dynamic language programs.•We validate our tracing techniques in an implementation basedon the SpiderMonkey JavaScript interpreter, achieving 2x-20xspeedups on many programs.The remainder of this paper is organized as follows. Section 3 isa general overview of trace tree based compilation we use to cap-ture and compile frequently executed code regions. In Section 4we describe our approach of covering nested loops using a num-ber of individual trace trees. In Section 5 we describe our trace-compilation based speculative type specialization approach we useto generate efficient machine code from recorded bytecode traces.Our implementation of a dynamic type-specializing compiler forJavaScript is described in Section 6. Related work is discussed inSection 8. In Section 7 we evaluate our dynamic compiler based on1 for (var i = 2; i < 100; ++i) {2   if (!primes[i])3     continue;4   for (var k = i + i; i < 100; k += i)5     primes[k] = false;6 }Figure 1. Sample program: sieve of Eratosthenes.primesisinitialized to an array of 100falsevalues on entry to this codesnippet.InterpretBytecodesMonitorRecordLIR TraceExecuteCompiled TraceEnterCompiled TraceCompileLIR TraceLeaveCompiled Traceloop edgehotloop/exitabort recordingfinish at loop headercold/blacklistedloop/exitcompiled trace readyloop edge with same typesside exit to existing traceside exit,no existing traceOverheadInterpretingNativeSymbol KeyFigure 2.State machine describing the major activities of Trace-Monkey and the conditions that cause transitions to a new activ-ity. In the dark box, TM executes JS as compiled traces. In thelight gray boxes, TM executes JS in the standard interpreter. Whiteboxes are overhead. Thus, to maximize performance, we need tomaximize time spent in the darkest box and minimize time spent inthe white boxes. The best case is a loop where the types at the loopedge are the same as the types on entry–then TM can stay in nativecode until the loop is done.a set of industry benchmarks. The paper ends with conclusions inSection 9 and an outlook on future work is presented in Section 10.2.  Overview: Example Tracing RunThis section provides an overview of our system by describinghow TraceMonkey executes an example program. The exampleprogram, shown in Figure 1, computes the first 100 prime numberswith nested loops. The narrative should be read along with Figure 2,which describes the activities TraceMonkey performs and when ittransitions between the loops.TraceMonkey always begins executing a program in the byte-code interpreter. Every loop back edge is a potential trace point.When the interpreter crosses a loop edge, TraceMonkey invokesthetrace monitor, which may decide to record or execute a nativetrace. At the start of execution, there are no compiled traces yet, sothe trace monitor counts the number of times each loop back edge isexecuted until a loop becomeshot, currently after 2 crossings. Notethat the way our loops are compiled, the loop edge is crossed beforeentering the loop, so the second crossing occurs immediately afterthe first iteration.Here is the sequence of events broken down by outer loopiteration:v0 := ld state[748]     // load primes from the trace activation recordst sp[0], v0      // store primes to interpreter stackv1 := ld state[764]     // load k from the trace activation recordv2 := i2f(v1)           // convert k from int to doublest sp[8], v1      // store k to interpreter stackst sp[16], 0      // store false to interpreter stackv3 := ld v0[4]          // load class word for primesv4 := and v3, -4        // mask out object class tag for primesv5 := eq v4, Array      // test whether primes is an arrayxf v5             // side exit if v5 is falsev6 := js_Array_set(v0, v2, false)  // call function to set array elementv7 := eq v6, 0          // test return value from callxt v7             // side exit if js_Array_set returns false.Figure 3. LIR snippet for sample program.This is the LIR recorded for line 5 of the sample program in Figure 1. The LIR encodesthe semantics in SSA form using temporary variables. The LIR also encodes all the stores that the interpreter would do to its data stack.Sometimes these stores can be optimized away as the stack locations are live only on exits to the interpreter. Finally, the LIR records guardsand side exits to verify the assumptions made in this recording: thatprimesis an array and that the call to set its element succeeds.mov edx, ebx(748)      // load primes from the trace activation recordmov edi(0), edx        // (*) store primes to interpreter stackmov esi, ebx(764)      // load k from the trace activation recordmov edi(8), esi        // (*) store k to interpreter stackmov edi(16), 0         // (*) store false to interpreter stackmov eax, edx(4)        // (*) load object class word for primesand eax, -4            // (*) mask out object class tag for primescmp eax, Array         // (*) test whether primes is an arrayjne side_exit_1        // (*) side exit if primes is not an arraysub esp, 8             // bump stack for call alignment conventionpush false             // push last argument for callpush esi               // push first argument for callcall js_Array_set      // call function to set array elementadd esp, 8             // clean up extra stack spacemov ecx, ebx           // (*) created by register allocatortest eax, eax          // (*) test return value of js_Array_setje side_exit_2         // (*) side exit if call failed...side_exit_1:mov ecx, ebp(-4)       // restore ecxmov esp, ebp           // restore espjmp epilog             // jump to ret statementFigure 4. x86 snippet for sample program.This is the x86 code compiled from the LIR snippet in Figure 3. Most LIR instructions compileto a single x86 instruction. Instructions marked with(*)would be omitted by an idealized compiler that knew that none of the side exitswould ever be taken. The 17 instructions generated by the compiler compare favorably with the 100+ instructions that the interpreter wouldexecute for the same code snippet, including 4 indirect jumps.i=2.This is the first iteration of the outer loop. The loop onlines 4-5 becomes hot on its second iteration, so TraceMonkey en-ters recording mode on line 4. In recording mode, TraceMonkeyrecords the code along the trace in a low-level compiler intermedi-ate representation we callLIR. The LIR trace encodes all the oper-ations performed and the types of all operands. The LIR trace alsoencodesguards, which are checks that verify that the control flowand types are identical to those observed during trace recording.Thus, on later executions, if and only if all guards are passed, thetrace has the required program semantics.TraceMonkey stops recording when execution returns to theloop header or exits the loop. In this case, execution returns to theloop header on line 4.After recording is finished, TraceMonkey compiles the trace tonative code using the recorded type information for optimization.The result is a native code fragment that can be entered if theinterpreter PC and the types of values match those observed whentrace recording was started. The first trace in our example,T45,covers lines 4 and 5. This trace can be entered if the PC is at line 4,iandkare integers, andprimesis an object. After compilingT45,TraceMonkey returns to the interpreter and loops back to line 1.i=3.Now the loop header at line 1 has become hot, so Trace-Monkey starts recording. When recording reaches line 4, Trace-Monkey observes that it has reached an inner loop header that al-ready has a compiled trace, so TraceMonkey attempts to nest theinner loop inside the current trace. The first step is to call the innertrace as a subroutine. This executes the loop on line 4 to completionand then returns to the recorder. TraceMonkey verifies that the callwas successful and then records the call to the inner trace as part ofthe current trace. Recording continues until execution reaches line1, and at which point TraceMonkey finishes and compiles a tracefor the outer loop,T16.', 'programs.', 'programs.Categories and Subject DescriptorsD.3.4 [Programming Lan-guages]: Processors —Incremental compilers, code generation.General TermsDesign, Experimentation, Measurement, Perfor-mance.KeywordsJavaScript, just-in-time compilation, trace trees.1.  IntroductionDynamic languagessuch as JavaScript, Python, and Ruby, are pop-ular since they are expressive, accessible to non-experts, and makedeployment as easy as distributing a source file. They are used forsmall scripts as well as for complex applications. JavaScript, forexample, is the de facto standard for client-side web programmingPermission to make digital or hard copies of all or part of this work for personal orclassroom use is granted without fee provided that copies are not made or distributedfor profit or commercial advantage and that copies bear this notice and the full citationon the first page. To copy otherwise, to republish, to post on servers or to redistributeto lists, requires prior specific permission and/or a fee.PLDI’09,June 15–20, 2009, Dublin, Ireland.Copyrightc©2009 ACM 978-1-60558-392-1/09/06. . . $5.00and is used for the application logic of browser-based productivityapplications such as Google Mail, Google Docs and Zimbra Col-laboration Suite. In this domain, in order to provide a fluid userexperience and enable a new generation of applications, virtual ma-chines must provide a low startup time and high performance.Compilers for statically typed languages rely on type informa-tion to generate efficient machine code. In a dynamically typed pro-gramming language such as JavaScript, the types of expressionsmay vary at runtime. This means that the compiler can no longereasily transform operations into machine instructions that operateon one specific type. Without exact type information, the compilermust emit slower generalized machine code that can deal with allpotential type combinations. While compile-time static type infer-ence might be able to gather type information to generate opti-mized machine code, traditional static analysis is very expensiveand hence not well suited for the highly interactive environment ofa web browser.We present a trace-based compilation technique for dynamiclanguages that reconciles speed of compilation with excellent per-formance of the generated machine code. Our system uses a mixed-mode execution approach: the system starts running JavaScript in afast-starting bytecode interpreter. As the program runs, the systemidentifieshot(frequently executed) bytecode sequences, recordsthem, and compiles them to fast native code. We call such a se-quence of instructions atrace.Unlike method-based dynamic compilers, our dynamic com-piler operates at the granularity of individual loops. This designchoice is based on the expectation that programs spend most oftheir time in hot loops. Even in dynamically typed languages, weexpect hot loops to be mostlytype-stable, meaning that the types ofvalues are invariant. (12) For example, we would expect loop coun-ters that start as integers to remain integers for all iterations. Whenboth of these expectations hold, a trace-based compiler can coverthe program execution with a small number of type-specialized, ef-ficiently compiled traces.Each compiled trace covers one path through the program withone mapping of values to types. When the VM executes a compiledtrace, it cannot guarantee that the same path will be followedor that the same types will occur in subsequent loop iterations.Hence, recording and compiling a tracespeculatesthat the path andtyping will be exactly as they were during recording for subsequentiterations of the loop.Every compiled trace contains all theguards(checks) requiredto validate the speculation. If one of the guards fails (if controlflow is different, or a value of a different type is generated), thetrace exits. If an exit becomes hot, the VM can record abranchtracestarting at the exit to cover the new path. In this way, the VMrecords atrace treecovering all the hot paths through the loop.Nested loops can be difficult to optimize for tracing VMs. Ina na ̈ıve implementation, inner loops would become hot first, andthe VM would start tracing there. When the inner loop exits, theVM would detect that a different branch was taken. The VM wouldtry to record a branch trace, and find that the trace reaches not theinner loop header, but the outer loop header. At this point, the VMcould continue tracing until it reaches the inner loop header again,thus tracing the outer loop inside a trace tree for the inner loop.But this requires tracing a copy of the outer loop for every side exitand type combination in the inner loop. In essence, this is a formof unintended tail duplication, which can easily overflow the codecache. Alternatively, the VM could simply stop tracing, and give upon ever tracing outer loops.We solve the nested loop problem by recordingnested tracetrees. Our system traces the inner loop exactly as the na ̈ıve version.The system stops extending the inner tree when it reaches an outerloop, but then it starts a new trace at the outer loop header. Whenthe outer loop reaches the inner loop header, the system tries to callthe trace tree for the inner loop. If the call succeeds, the VM recordsthe call to the inner tree as part of the outer trace and finishesthe outer trace as normal. In this way, our system can trace anynumber of loops nested to any depth without causing excessive tailduplication.These techniques allow a VM to dynamically translate a pro-gram to nested, type-specialized trace trees. Because traces cancross function call boundaries, our techniques also achieve the ef-fects of inlining. Because traces have no internal control-flow joins,they can be optimized in linear time by a simple compiler (10).Thus, our tracing VM efficiently performs the same kind of op-timizations that would require interprocedural analysis in a staticoptimization setting. This makes tracing an attractive and effectivetool to type specialize even complex function call-rich code.We implemented these techniques for an existing JavaScript in-terpreter, SpiderMonkey. We call the resulting tracing VMTrace-Monkey. TraceMonkey supports all the JavaScript features of Spi-derMonkey, with a 2x-20x speedup for traceable programs.This paper makes the following contributions:•We explain an algorithm for dynamically forming trace trees tocover a program, representing nested loops as nested trace trees.•We explain how to speculatively generate efficient type-specializedcode for traces from dynamic language programs.•We validate our tracing techniques in an implementation basedon the SpiderMonkey JavaScript interpreter, achieving 2x-20xspeedups on many programs.The remainder of this paper is organized as follows. Section 3 isa general overview of trace tree based compilation we use to cap-ture and compile frequently executed code regions. In Section 4we describe our approach of covering nested loops using a num-ber of individual trace trees. In Section 5 we describe our trace-compilation based speculative type specialization approach we useto generate efficient machine code from recorded bytecode traces.Our implementation of a dynamic type-specializing compiler forJavaScript is described in Section 6. Related work is discussed inSection 8. In Section 7 we evaluate our dynamic compiler based on1 for (var i = 2; i < 100; ++i) {2   if (!primes[i])3     continue;4   for (var k = i + i; i < 100; k += i)5     primes[k] = false;6 }Figure 1. Sample program: sieve of Eratosthenes.primesisinitialized to an array of 100falsevalues on entry to this codesnippet.InterpretBytecodesMonitorRecordLIR TraceExecuteCompiled TraceEnterCompiled TraceCompileLIR TraceLeaveCompiled Traceloop edgehotloop/exitabort recordingfinish at loop headercold/blacklistedloop/exitcompiled trace readyloop edge with same typesside exit to existing traceside exit,no existing traceOverheadInterpretingNativeSymbol KeyFigure 2.State machine describing the major activities of Trace-Monkey and the conditions that cause transitions to a new activ-ity. In the dark box, TM executes JS as compiled traces. In thelight gray boxes, TM executes JS in the standard interpreter. Whiteboxes are overhead. Thus, to maximize performance, we need tomaximize time spent in the darkest box and minimize time spent inthe white boxes. The best case is a loop where the types at the loopedge are the same as the types on entry–then TM can stay in nativecode until the loop is done.a set of industry benchmarks. The paper ends with conclusions inSection 9 and an outlook on future work is presented in Section 10.2.  Overview: Example Tracing RunThis section provides an overview of our system by describinghow TraceMonkey executes an example program. The exampleprogram, shown in Figure 1, computes the first 100 prime numberswith nested loops. The narrative should be read along with Figure 2,which describes the activities TraceMonkey performs and when ittransitions between the loops.TraceMonkey always begins executing a program in the byte-code interpreter. Every loop back edge is a potential trace point.When the interpreter crosses a loop edge, TraceMonkey invokesthetrace monitor, which may decide to record or execute a nativetrace. At the start of execution, there are no compiled traces yet, sothe trace monitor counts the number of times each loop back edge isexecuted until a loop becomeshot, currently after 2 crossings. Notethat the way our loops are compiled, the loop edge is crossed beforeentering the loop, so the second crossing occurs immediately afterthe first iteration.Here is the sequence of events broken down by outer loopiteration:v0 := ld state[748]     // load primes from the trace activation recordst sp[0], v0      // store primes to interpreter stackv1 := ld state[764]     // load k from the trace activation recordv2 := i2f(v1)           // convert k from int to doublest sp[8], v1      // store k to interpreter stackst sp[16], 0      // store false to interpreter stackv3 := ld v0[4]          // load class word for primesv4 := and v3, -4        // mask out object class tag for primesv5 := eq v4, Array      // test whether primes is an arrayxf v5             // side exit if v5 is falsev6 := js_Array_set(v0, v2, false)  // call function to set array elementv7 := eq v6, 0          // test return value from callxt v7             // side exit if js_Array_set returns false.Figure 3. LIR snippet for sample program.This is the LIR recorded for line 5 of the sample program in Figure 1. The LIR encodesthe semantics in SSA form using temporary variables. The LIR also encodes all the stores that the interpreter would do to its data stack.Sometimes these stores can be optimized away as the stack locations are live only on exits to the interpreter. Finally, the LIR records guardsand side exits to verify the assumptions made in this recording: thatprimesis an array and that the call to set its element succeeds.mov edx, ebx(748)      // load primes from the trace activation recordmov edi(0), edx        // (*) store primes to interpreter stackmov esi, ebx(764)      // load k from the trace activation recordmov edi(8), esi        // (*) store k to interpreter stackmov edi(16), 0         // (*) store false to interpreter stackmov eax, edx(4)        // (*) load object class word for primesand eax, -4            // (*) mask out object class tag for primescmp eax, Array         // (*) test whether primes is an arrayjne side_exit_1        // (*) side exit if primes is not an arraysub esp, 8             // bump stack for call alignment conventionpush false             // push last argument for callpush esi               // push first argument for callcall js_Array_set      // call function to set array elementadd esp, 8             // clean up extra stack spacemov ecx, ebx           // (*) created by register allocatortest eax, eax          // (*) test return value of js_Array_setje side_exit_2         // (*) side exit if call failed...side_exit_1:mov ecx, ebp(-4)       // restore ecxmov esp, ebp           // restore espjmp epilog             // jump to ret statementFigure 4. x86 snippet for sample program.This is the x86 code compiled from the LIR snippet in Figure 3. Most LIR instructions compileto a single x86 instruction. Instructions marked with(*)would be omitted by an idealized compiler that knew that none of the side exitswould ever be taken. The 17 instructions generated by the compiler compare favorably with the 100+ instructions that the interpreter wouldexecute for the same code snippet, including 4 indirect jumps.i=2.This is the first iteration of the outer loop. The loop onlines 4-5 becomes hot on its second iteration, so TraceMonkey en-ters recording mode on line 4. In recording mode, TraceMonkeyrecords the code along the trace in a low-level compiler intermedi-ate representation we callLIR. The LIR trace encodes all the oper-ations performed and the types of all operands. The LIR trace alsoencodesguards, which are checks that verify that the control flowand types are identical to those observed during trace recording.Thus, on later executions, if and only if all guards are passed, thetrace has the required program semantics.TraceMonkey stops recording when execution returns to theloop header or exits the loop. In this case, execution returns to theloop header on line 4.After recording is finished, TraceMonkey compiles the trace tonative code using the recorded type information for optimization.The result is a native code fragment that can be entered if theinterpreter PC and the types of values match those observed whentrace recording was started. The first trace in our example,T45,covers lines 4 and 5. This trace can be entered if the PC is at line 4,iandkare integers, andprimesis an object. After compilingT45,TraceMonkey returns to the interpreter and loops back to line 1.i=3.Now the loop header at line 1 has become hot, so Trace-Monkey starts recording. When recording reaches line 4, Trace-Monkey observes that it has reached an inner loop header that al-ready has a compiled trace, so TraceMonkey attempts to nest theinner loop inside the current trace. The first step is to call the innertrace as a subroutine. This executes the loop on line 4 to completionand then returns to the recorder. TraceMonkey verifies that the callwas successful and then records the call to the inner trace as part ofthe current trace. Recording continues until execution reaches line1, and at which point TraceMonkey finishes and compiles a tracefor the outer loop,T16.', 'Otra Observacion', '2017-06-20 11:16:42', 'p', '1', 21, 24),
(8, 'trace. At the start of execution, there are no compiled traces yet, sothe trace monitor counts the number of times each loop back edge isexecuted until a loop becomeshot, currently after 2 crossings. Notethat the way our loops are compiled, the loop edge is crossed beforeentering the loop, so the second crossing occurs immediately afterthe first iteration.', 'trace. At the start of execution, there are no compiled traces yet, so', 'trace. At the start of execution, there are no compiled traces yet, sothe trace monitor counts the number of times each loop back edge isexecuted until a loop becomeshot, currently after 2 crossings. Notethat the way our loops are compiled, the loop edge is crossed beforeentering the loop, so the second crossing occurs immediately afterthe first iteration.', 'Tercera', '2017-06-20 11:17:56', 'p', '2', 21, 24);
INSERT INTO `Observation` (`id`, `text`, `textstart`, `textend`, `description`, `date`, `status`, `npage`, `id_teacher`, `id_document`) VALUES
(9, 'will not be reused.  If, on the other hand, both use the same “format” for host addresses, interoperabilitywill be successful. There are two ways to solve this problem:1.  Use‘‘-ORBdotteddecimaladdresses 1’’as  an  command  line  argument  to  the  TAOserver.2.  Configure JacORB to use DNS names (See the configuration guide).16  Portable InterceptorsSince revision 1.1 JacORB provides support for Portable Interceptors These interceptors are compliant tothe standard CORBA specification.  Therefore we don’t provide any documentation on how to programinterceptors but supply a few (hopefully helpful) hints and tips on JacORB specific solutions.The first step to have an interceptor integrated into the ORB is to register anORBInitializer.  This isdone by setting a property the following way:org.omg.PortableInterceptor.ORBInitializerClass.<any_suffix>=<orb initializer classname>For compatibility reasons with the spec, the properties format may also be like this:org.omg.PortableInterceptor.ORBInitializerClass.<orb initializer classname>The suffix is just to distinguish between different initializers and doesn’t have to have any meaningfulvalue.  The value of the property however has to be the fully qualified classname of the initializer.  If theverbosity is set to≥2JacORB will display aClassNotFoundExceptionin case the initializers classis not in the class path.An example line might look like:org.omg.PortableInterceptor.ORBInitializerClass.my_init=test.MyInterceptorInitializerUnfortunately  the  interfaces  of  the  specification  don’t  provide  any  access  to  the  ORB.  If  you  needaccess  to  the  ORB  from  out  of  the  initializer  you  can  cast  theORBInitInfoobject  tojacorb.orb.portableInterceptor.ORBInitInfoImpland callgetORB()to get a reference to theORB that instantiated the initializer.When working with service contexts please make sure that you don’t use0x4A414301as an id be-cause a service context with that id is used internally. Otherwise you will end up with either your data nottransfered or unexpected internal exceptions.16.1  Interceptor ForwardRequest ExceptionsSeveraloftheinterceptortypesmaythrowaForwardExceptionsuchasClientRequestInterceptor sendrequest.    A  developer  may  wish  to  do  this  if,  for  in-stance, a new policy is being applied to the object to switch to a SSL connection type as suggested withinchapter 20.132Portable InterceptorsA current limitation of the specification (CORBA 3; 02-06-33) is that it is impossible to detect whetherthe call has previously been thrown for the same client request. Thus it is possible to enter an infinite loopthrowing ForwardRequest at this point.  This issue was first submitted to the OMG in May 2002 undernumber 5266.In order to allow developers more flexibility when writing their interceptors PrismTech have enhancedthe exception handling as follows.   We have chosen one of the solutions proposed within issue 5266;namely to allow forwardreference() to be accessed in sendrequest() as well as in receiveother().  i.e.returning the object from the previous ForwardRequest if that has been thrown and null otherwise.A typical use of this might bepublic void send_request( ClientRequestInfo ri ){if (ri.effective_profile().tag == TAG_INTERNET_IOP.value &&ri.forward_reference() == null){// Do some processing, throw a forward request.}}This allows the developer to conditionally throw a forward request while using forwardreference() toprevent infinite loops.16.2  Public APISome users may find it useful to access internal data on the ClientRequestInfo and ServerRequestInfo.The following API is available. Note that it may be possible to corrupt the call chain so use these at yourown risk.isLocalInterceptorsreturns true if the interceptors are running locally (i.e. no TCP connectionis being used and thereforegetConnectionwill return null).org.jacorb.orb.portableInterceptor.ServerRequestInfoImplpublic boolean isLocalInterceptors()public GIOPConnection getConnection()public ReplyOutputStream getReplyStream ()public RequestInputStream getRequestStream ()public ORB orb()org.jacorb.orb.portableInterceptor.ClientRequestInfoImplpublic boolean isLocalInterceptors()18  Quality of ServiceJacORB implements a subset of the QoS policies defined in chapter 22.2 of the CORBA 3.0 specification.In the following, we describe each of the policies we have currently implemented, along with notes onparticular JacORB issues concerning each policy.  Policies not listed in the following are not yet imple-mented.As of yet, all policies described in this chapter areclient-sideoverridepolicies.  The CORBA specifi-cation uses the term for any policy that is explicitly set and thus overrides system defaults.  Policies canbe set at different scopes:  per object, per thread, or per ORB. The current JacORB implementation onlysupports object and ORB scopes. In general, the following steps are necessary:Step 1.Get ananyfrom the ORB and put the value for the policy into it.Step 2.Get a Policy object from the ORB which encapsulates the desired value (theanyvalue from theprevious step).Step 3.Apply the policy to a particular object using thesetpolicyoverride()operation on theobject reference.Step 3.alternatively:  set the policy ORB-wide using thesetpolicyoverrides()operation onthe ORB’sPolicyManagerobject.Below is the code that corresponds to the steps listed above, using theSyncScopePolicy (described inthe following section) as an example. Also, have a look at the demo program indemo/policies:SomeCorbaType     server = ...org.omg.CORBA.ORB orb    = ...org.omg.CORBA.Any a      = orb.create_any();a.insert_short(SYNC_WITH_SERVER.value); // the value for that policytry{Policy p = orb.create_policy(SYNC_SCOPE_POLICY_TYPE.value, a);server-new = ServerHelper.narrow(server._set_policy_override (new Policy[]{ p },SetOverrideType.ADD_OVERRIDE));server._release();// get the ORB’s policy managerPolicyManager policyManager =PolicyManagerHelper.narrow(orb.resolve_initial_references("ORBPolicyManager"));18.2 Timing Policies141ProgrammingIn  CORBA,  points  of  time  are  specified  to  an  accuracy  of  100  nanoseconds,  using  values  of  structTimeBase::UtcT. To allow easy manipulation of such values from Java,  JacORB provides a num-ber of static methods inorg.jacorb.util.Time. For example, to convert the current Java time intoaUtcTvalue, writeUtcT currentTime = org.jacorb.util.Time.corbaTime();To create aUtcTvalue that specifies a timenmilliseconds in the future, you can writeUtcT time = org.jacorb.util.Time.corbaFuture (10000*n);(The argument tocorbaFuture()is in CORBA time units of 100 ns; we multiplynby 10000 hereto convert it from Java time units (milliseconds).)The following shows how to set a timing policy for an object using the standard mechanism (see thebeginning of this chapter for an explanation).  In this example, we set aReplyEndTime that lies onesecond in the future:import org.omg.CORBA.*;SomeCorbaType server  = ...  // the object for which we want to set// a timing policyorg.omg.CORBA.ORB orb = ...org.omg.CORBA.Any a   = orb.create_any();org.omg.TimeBase.UtcT replyEndTime= org.jacorb.util.Time.corbaFuture (1000*10000);  // one secondorg.omg.TimeBase.UtcTHelper.insert (a, replyEndTime);try{Policy p= orb.create_policy (REPLY_END_TIME_POLICY_TYPE.value, a);server-new = ServerHelper.narrow(server._set_policy_override (new Policy[]{ p },SetOverrideType.ADD_OVERRIDE));server._release();}catch (PolicyError e){...}142Quality of ServiceUsing the constructors of JacORB’s implementations of policy values, this becomes less verbose:SomeCorbaType server  = ...Policy p = new org.jacorb.orb.policies.ReplyEndTimePolicy(org.jacorb.util.Time.corbaFuture (1000*10000));server-new = ServerHelper.narrow(server._set_policy_override (new Policy[]{ p },SetOverrideType.ADD_OVERRIDE));server._release();Likewise, to set aRelativeRoundtripTimeout of one second, write:SomeCorbaType server  = ...Policy p =new org.jacorb.orb.policies.RelativeRoundtripTimeoutPolicy(1000*10000);server-new = ServerHelper.narrow(server._set_policy_override (new Policy[]{ p },SetOverrideType.ADD_OVERRIDE));server._release();The difference between this and the example before, where aReplyEndTime was used, is that thelatter specifies arelativetime to CORBA. The policy will therefore be valid for all subsequent invocations,because the absolute deadline will be recomputed before each invocation. In the first example, the deadlinewill no longer make sense for any subsequent invocations, since only an absolute time was specified to theORB.19  Connection Management andConnection TimeoutsJacORB offers a certain level of control over connections and timeouts. You can•set connection idle timeouts.•set request timing.•set the maximum number of accepted TCP/IP connections on the server.19.1  TimeoutsConnection   idle   timeouts   can   be   set   individually   for   the   client   and   the   server.They   con-trol   how   long   an   idle   connection,   i.e.   a   connection   that   has   no   pending   replies,   will   stayopen.The  corresponding  properties  arejacorb.connection.client.idletimeoutandjacorb.connection.server.timeoutand  take  their  values  as  milliseconds.   If  not  set,  con-nections will stay open indefinitely (or until the OS decides to close them).Requesttiming controls how long an individual request may take to complete.  The programmer canspecify this using QoS policies, discussed in chapter 18.19.2  Connection ManagementWhen a client wants to invoke a remote object, it needs to send the request over a connection to the server.If the connection isn’t present,  it has to be created.   In JacORB, this will only happen once for everycombination of host name and port.  Once the connection is established, all requests and replies betweenclient and server will use the same connection. This saves resources while adding a thin layer of necessarysynchronization, and is the recommended approach of the OMG. Occasionally people have requested toallow for multiple connections to the same server, but nobody has yet presented a good argument thatmore connections would speed up things considerably.Connections are typically blocking, with a separate thread used to handle sending and receving dataand managing time-outs.  In cases of heavy load where the client may connect to dozens or hundreds ofservers, and is using timeouts, this behavior can lead to very poor performance due to thead thrashing. Toavoid this problem, JacORB 3.0.0 now makes available a non blocking mode for client side connections.Enabling this feature causes the client to use non-blocking connection establishment, sending of requests', 'will not be reused.  If, on the other hand, both use the same “format” for host addresses, interoperability', 'will not be reused.  If, on the other hand, both use the same “format” for host addresses, interoperabilitywill be successful. There are two ways to solve this problem:1.  Use‘‘-ORBdotteddecimaladdresses 1’’as  an  command  line  argument  to  the  TAOserver.2.  Configure JacORB to use DNS names (See the configuration guide).16  Portable InterceptorsSince revision 1.1 JacORB provides support for Portable Interceptors These interceptors are compliant tothe standard CORBA specification.  Therefore we don’t provide any documentation on how to programinterceptors but supply a few (hopefully helpful) hints and tips on JacORB specific solutions.The first step to have an interceptor integrated into the ORB is to register anORBInitializer.  This isdone by setting a property the following way:org.omg.PortableInterceptor.ORBInitializerClass.<any_suffix>=<orb initializer classname>For compatibility reasons with the spec, the properties format may also be like this:org.omg.PortableInterceptor.ORBInitializerClass.<orb initializer classname>The suffix is just to distinguish between different initializers and doesn’t have to have any meaningfulvalue.  The value of the property however has to be the fully qualified classname of the initializer.  If theverbosity is set to≥2JacORB will display aClassNotFoundExceptionin case the initializers classis not in the class path.An example line might look like:org.omg.PortableInterceptor.ORBInitializerClass.my_init=test.MyInterceptorInitializerUnfortunately  the  interfaces  of  the  specification  don’t  provide  any  access  to  the  ORB.  If  you  needaccess  to  the  ORB  from  out  of  the  initializer  you  can  cast  theORBInitInfoobject  tojacorb.orb.portableInterceptor.ORBInitInfoImpland callgetORB()to get a reference to theORB that instantiated the initializer.When working with service contexts please make sure that you don’t use0x4A414301as an id be-cause a service context with that id is used internally. Otherwise you will end up with either your data nottransfered or unexpected internal exceptions.16.1  Interceptor ForwardRequest ExceptionsSeveraloftheinterceptortypesmaythrowaForwardExceptionsuchasClientRequestInterceptor sendrequest.    A  developer  may  wish  to  do  this  if,  for  in-stance, a new policy is being applied to the object to switch to a SSL connection type as suggested withinchapter 20.132Portable InterceptorsA current limitation of the specification (CORBA 3; 02-06-33) is that it is impossible to detect whetherthe call has previously been thrown for the same client request. Thus it is possible to enter an infinite loopthrowing ForwardRequest at this point.  This issue was first submitted to the OMG in May 2002 undernumber 5266.In order to allow developers more flexibility when writing their interceptors PrismTech have enhancedthe exception handling as follows.   We have chosen one of the solutions proposed within issue 5266;namely to allow forwardreference() to be accessed in sendrequest() as well as in receiveother().  i.e.returning the object from the previous ForwardRequest if that has been thrown and null otherwise.A typical use of this might bepublic void send_request( ClientRequestInfo ri ){if (ri.effective_profile().tag == TAG_INTERNET_IOP.value &&ri.forward_reference() == null){// Do some processing, throw a forward request.}}This allows the developer to conditionally throw a forward request while using forwardreference() toprevent infinite loops.16.2  Public APISome users may find it useful to access internal data on the ClientRequestInfo and ServerRequestInfo.The following API is available. Note that it may be possible to corrupt the call chain so use these at yourown risk.isLocalInterceptorsreturns true if the interceptors are running locally (i.e. no TCP connectionis being used and thereforegetConnectionwill return null).org.jacorb.orb.portableInterceptor.ServerRequestInfoImplpublic boolean isLocalInterceptors()public GIOPConnection getConnection()public ReplyOutputStream getReplyStream ()public RequestInputStream getRequestStream ()public ORB orb()org.jacorb.orb.portableInterceptor.ClientRequestInfoImplpublic boolean isLocalInterceptors()18  Quality of ServiceJacORB implements a subset of the QoS policies defined in chapter 22.2 of the CORBA 3.0 specification.In the following, we describe each of the policies we have currently implemented, along with notes onparticular JacORB issues concerning each policy.  Policies not listed in the following are not yet imple-mented.As of yet, all policies described in this chapter areclient-sideoverridepolicies.  The CORBA specifi-cation uses the term for any policy that is explicitly set and thus overrides system defaults.  Policies canbe set at different scopes:  per object, per thread, or per ORB. The current JacORB implementation onlysupports object and ORB scopes. In general, the following steps are necessary:Step 1.Get ananyfrom the ORB and put the value for the policy into it.Step 2.Get a Policy object from the ORB which encapsulates the desired value (theanyvalue from theprevious step).Step 3.Apply the policy to a particular object using thesetpolicyoverride()operation on theobject reference.Step 3.alternatively:  set the policy ORB-wide using thesetpolicyoverrides()operation onthe ORB’sPolicyManagerobject.Below is the code that corresponds to the steps listed above, using theSyncScopePolicy (described inthe following section) as an example. Also, have a look at the demo program indemo/policies:SomeCorbaType     server = ...org.omg.CORBA.ORB orb    = ...org.omg.CORBA.Any a      = orb.create_any();a.insert_short(SYNC_WITH_SERVER.value); // the value for that policytry{Policy p = orb.create_policy(SYNC_SCOPE_POLICY_TYPE.value, a);server-new = ServerHelper.narrow(server._set_policy_override (new Policy[]{ p },SetOverrideType.ADD_OVERRIDE));server._release();// get the ORB’s policy managerPolicyManager policyManager =PolicyManagerHelper.narrow(orb.resolve_initial_references("ORBPolicyManager"));18.2 Timing Policies141ProgrammingIn  CORBA,  points  of  time  are  specified  to  an  accuracy  of  100  nanoseconds,  using  values  of  structTimeBase::UtcT. To allow easy manipulation of such values from Java,  JacORB provides a num-ber of static methods inorg.jacorb.util.Time. For example, to convert the current Java time intoaUtcTvalue, writeUtcT currentTime = org.jacorb.util.Time.corbaTime();To create aUtcTvalue that specifies a timenmilliseconds in the future, you can writeUtcT time = org.jacorb.util.Time.corbaFuture (10000*n);(The argument tocorbaFuture()is in CORBA time units of 100 ns; we multiplynby 10000 hereto convert it from Java time units (milliseconds).)The following shows how to set a timing policy for an object using the standard mechanism (see thebeginning of this chapter for an explanation).  In this example, we set aReplyEndTime that lies onesecond in the future:import org.omg.CORBA.*;SomeCorbaType server  = ...  // the object for which we want to set// a timing policyorg.omg.CORBA.ORB orb = ...org.omg.CORBA.Any a   = orb.create_any();org.omg.TimeBase.UtcT replyEndTime= org.jacorb.util.Time.corbaFuture (1000*10000);  // one secondorg.omg.TimeBase.UtcTHelper.insert (a, replyEndTime);try{Policy p= orb.create_policy (REPLY_END_TIME_POLICY_TYPE.value, a);server-new = ServerHelper.narrow(server._set_policy_override (new Policy[]{ p },SetOverrideType.ADD_OVERRIDE));server._release();}catch (PolicyError e){...}142Quality of ServiceUsing the constructors of JacORB’s implementations of policy values, this becomes less verbose:SomeCorbaType server  = ...Policy p = new org.jacorb.orb.policies.ReplyEndTimePolicy(org.jacorb.util.Time.corbaFuture (1000*10000));server-new = ServerHelper.narrow(server._set_policy_override (new Policy[]{ p },SetOverrideType.ADD_OVERRIDE));server._release();Likewise, to set aRelativeRoundtripTimeout of one second, write:SomeCorbaType server  = ...Policy p =new org.jacorb.orb.policies.RelativeRoundtripTimeoutPolicy(1000*10000);server-new = ServerHelper.narrow(server._set_policy_override (new Policy[]{ p },SetOverrideType.ADD_OVERRIDE));server._release();The difference between this and the example before, where aReplyEndTime was used, is that thelatter specifies arelativetime to CORBA. The policy will therefore be valid for all subsequent invocations,because the absolute deadline will be recomputed before each invocation. In the first example, the deadlinewill no longer make sense for any subsequent invocations, since only an absolute time was specified to theORB.19  Connection Management andConnection TimeoutsJacORB offers a certain level of control over connections and timeouts. You can•set connection idle timeouts.•set request timing.•set the maximum number of accepted TCP/IP connections on the server.19.1  TimeoutsConnection   idle   timeouts   can   be   set   individually   for   the   client   and   the   server.They   con-trol   how   long   an   idle   connection,   i.e.   a   connection   that   has   no   pending   replies,   will   stayopen.The  corresponding  properties  arejacorb.connection.client.idletimeoutandjacorb.connection.server.timeoutand  take  their  values  as  milliseconds.   If  not  set,  con-nections will stay open indefinitely (or until the OS decides to close them).Requesttiming controls how long an individual request may take to complete.  The programmer canspecify this using QoS policies, discussed in chapter 18.19.2  Connection ManagementWhen a client wants to invoke a remote object, it needs to send the request over a connection to the server.If the connection isn’t present,  it has to be created.   In JacORB, this will only happen once for everycombination of host name and port.  Once the connection is established, all requests and replies betweenclient and server will use the same connection. This saves resources while adding a thin layer of necessarysynchronization, and is the recommended approach of the OMG. Occasionally people have requested toallow for multiple connections to the same server, but nobody has yet presented a good argument thatmore connections would speed up things considerably.Connections are typically blocking, with a separate thread used to handle sending and receving dataand managing time-outs.  In cases of heavy load where the client may connect to dozens or hundreds ofservers, and is using timeouts, this behavior can lead to very poor performance due to thead thrashing. Toavoid this problem, JacORB 3.0.0 now makes available a non blocking mode for client side connections.Enabling this feature causes the client to use non-blocking connection establishment, sending of requests', 'Primer Observacion', '2017-06-20 11:20:30', 'p', '130', 21, 10);
INSERT INTO `Observation` (`id`, `text`, `textstart`, `textend`, `description`, `date`, `status`, `npage`, `id_teacher`, `id_document`) VALUES
(10, 'question.Representation specialization: objects.In JavaScript, namelookup semantics are complex and potentially expensive becausethey include features like object inheritance andeval. To evaluatean object property read expression likeo.x, the interpreter mustsearch the property map ofoand all of its prototypes and parents.Property maps can be implemented with different data structures(e.g., per-object hash tables or shared hash tables), so the searchprocess also must dispatch on the representation of each objectfound during search. TraceMonkey can simply observe the result ofthe search process and record the simplest possible LIR to accessthe property value. For example, the search might finds the value ofo.xin the prototype ofo, which uses a shared hash-table represen-tation that placesxin slot 2 of a property vector. Then the recordedcan generate LIR that readso.xwith just two or three loads: one toget the prototype, possibly one to get the property value vector, andone more to get slot 2 from the vector. This is a vast simplificationand speedup compared to the original interpreter code. Inheritancerelationships and object representations can change during execu-tion, so the simplified code requires guard instructions that ensurethe object representation is the same. In TraceMonkey, objects’ rep-resentations are assigned an integer key called theobject shape.Thus, the guard is a simple equality check on the object shape.Representation specialization: numbers.JavaScript has nointeger type, only a Number type that is the set of 64-bit IEEE-754 floating-pointer numbers (“doubles”). But many JavaScriptoperators, in particular array accesses and bitwise operators, reallyoperate on integers, so they first convert the number to an integer,and then convert any integer result back to a double.1Clearly, aJavaScript VM that wants to be fast must find a way to operate onintegers directly and avoid these conversions.In TraceMonkey, we support two representations for numbers:integers and doubles. The interpreter uses integer representationsas much as it can, switching for results that can only be representedas doubles. When a trace is started, some values may be importedand represented as integers. Some operations on integers requireguards. For example, adding two integers can produce a value toolarge for the integer representation.Function inlining.LIR traces can cross function boundariesin either direction, achieving function inlining. Move instructionsneed to be recorded for function entry and exit to copy argumentsin and return values out. These move statements are then optimizedaway by the compiler using copy propagation. In order to be ableto return to the interpreter, the trace must also generate LIR torecord that a call frame has been entered and exited. The frameentry and exit LIR saves just enough information to allow theintepreter call stack to be restored later and is much simpler thanthe interpreter’s standard call code. If the function being enteredis not constant (which in JavaScript includes any call by functionname), the recorder must also emit LIR to guard that the functionis the same.Guards and side exits.Each optimization described aboverequires one or more guards to verify the assumptions made indoing the optimization. A guard is just a group of LIR instructionsthat performs a test and conditional exit. The exit branches to aside exit, a small off-trace piece of LIR that returns a pointer toa structure that describes the reason for the exit along with theinterpreter PC at the exit point and any other data needed to restorethe interpreter’s state structures.Aborts.Some constructs are difficult to record in LIR traces.For example,evalor calls to external functions can change theprogram state in unpredictable ways, making it difficult for thetracer to know the current type map in order to continue tracing.A tracing implementation can also have any number of other limi-tations, e.g.,a small-memory device may limit the length of traces.When any situation occurs that prevents the implementation fromcontinuing trace recording, the implementationabortstrace record-ing and returns to the trace monitor.3.2  Trace TreesEspecially simple loops, namely those where control flow, valuetypes, value representations, and inlined functions are all invariant,can be represented by a single trace. But most loops have at leastsome variation, and so the program will take side exits from themain trace. When a side exit becomes hot, TraceMonkey starts anewbranch tracefrom that point and patches the side exit to jumpdirectly to that trace. In this way, a single trace expands on demandto a single-entry, multiple-exittrace tree.This section explains how trace trees are formed during execu-tion. The goal is to form trace trees during execution that cover allthe hot paths of the program.1Arrays are actually worse than this: if the index value is a number, it mustbe converted from a double to a string for the property access operator, andthen to an integer internally to the array implementation.Starting a tree.Tree trees always start at loop headers, becausethey are a natural place to look for hot paths. In TraceMonkey, loopheaders are easy to detect–the bytecode compiler ensures that abytecode is a loop header iff it is the target of a backward branch.TraceMonkey starts a tree when a given loop header has been exe-cuted a certain number of times (2 in the current implementation).Starting a tree just means starting recording a trace for the currentpoint and type map and marking the trace as the root of a tree. Eachtree is associated with a loop header and type map, so there may beseveral trees for a given loop header.Closing the loop.Trace recording can end in several ways.Ideally, the trace reaches the loop header where it started withthe same type map as on entry. This is called atype-stableloopiteration. In this case, the end of the trace can jump right to thebeginning, as all the value representations are exactly as needed toenter the trace. The jump can even skip the usual code that wouldcopy out the state at the end of the trace and copy it back in to thetrace activation record to enter a trace.In certain cases the trace might reach the loop header with adifferent type map. This scenario is sometime observed for the firstiteration of a loop. Some variables inside the loop might initially beundefined, before they are set to a concrete type during the first loopiteration. When recording such an iteration, the recorder cannotlink the trace back to its own loop header since it istype-unstable.Instead, the iteration is terminated with a side exit that will alwaysfail and return to the interpreter. At the same time a new trace isrecorded with the new type map. Every time an additional type-unstable trace is added to a region, its exit type map is compared tothe entry map of all existing traces in case they complement eachother. With this approach we are able to cover type-unstable loopiterations as long they eventually form a stable equilibrium.Finally, the trace might exit the loop before reaching the loopheader, for example because execution reaches abreakorreturnstatement. In this case, the VM simply ends the trace with an exitto the trace monitor.As mentioned previously, we may speculatively chose to rep-resent certain Number-typed values as integers on trace. We do sowhen we observe that Number-typed variables contain an integervalue at trace entry. If during trace recording the variable is unex-pectedly assigned a non-integer value, we have to widen the typeof the variable to a double. As a result, the recorded trace becomesinherently type-unstable since it starts with an integer value butends with a double value. This represents a mis-speculation, sinceat trace entry we specialized the Number-typed value to an integer,assuming that at the loop edge we would again find an integer valuein the variable, allowing us to close the loop. To avoid future spec-ulative failures involving this variable, and to obtain a type-stabletrace we note the fact that the variable in question as been observedto sometimes hold non-integer values in an advisory data structurewhich we call the “oracle”.When compiling loops, we consult the oracle before specializ-ing values to integers. Speculation towards integers is performedonly if no adverse information is known to the oracle about thatparticular variable. Whenever we accidentally compile a loop thatis type-unstable due to mis-speculation of a Number-typed vari-able, we immediately trigger the recording of a new trace, whichbased on the now updated oracle information will start with a dou-ble value and thus become type stable.Extending a tree.Side exits lead to different paths throughthe loop, or paths with different types or representations. Thus, tocompletely cover the loop, the VM must record traces starting at allside exits. These traces are recorded much like root traces: there isa counter for each side exit, and when the counter reaches a hotnessthreshold, recording starts. Recording stops exactly as for the roottrace, using the loop header of the root trace as the target to reach.Our implementation does not extend at all side exits. It extendsonly if the side exit is for a control-flow branch, and only if the sideexit does not leave the loop. In particular we do not want to extenda trace tree along a path that leads to an outer loop, because wewant to cover such paths in an outer tree through treenesting.3.3  BlacklistingSometimes, a program follows a path that cannot be compiledinto a trace, usually because of limitations in the implementation.TraceMonkey does not currently support recording throwing andcatching of arbitrary exceptions. This design trade off was chosen,because exceptions are usually rare in JavaScript. However, if aprogram opts to use exceptions intensively, we would suddenlyincur a punishing runtime overhead if we repeatedly try to recorda trace for this path and repeatedly fail to do so, since we aborttracing every time we observe an exception being thrown.As a result, if a hot loop contains traces that always fail, the VMcould potentially run much more slowly than the base interpreter:the VM repeatedly spends time trying to record traces, but is neverable to run any. To avoid this problem, whenever the VM is aboutto start tracing, it must try to predict whether it will finish the trace.Our prediction algorithm is based onblacklistingtraces thathave been tried and failed. When the VM fails to finish a trace start-ing at a given point, the VM records that a failure has occurred. TheVM also sets a counter so that it will not try to record a trace startingat that point until it is passed a few more times (32 in our imple-mentation). Thisbackoffcounter gives temporary conditions thatprevent tracing a chance to end. For example, a loop may behavedifferently during startup than during its steady-state execution. Af-ter a given number of failures (2 in our implementation), the VMmarks the fragment as blacklisted, which means the VM will neveragain start recording at that point.After implementing this basic strategy, we observed that forsmall loops that get blacklisted, the system can spend a noticeableamount of time just finding the loop fragment and determining thatit has been blacklisted. We now avoid that problem by patching thebytecode. We define an extra no-op bytecode that indicates a loopheader. The VM calls into the trace monitor every time the inter-preter executes a loop header no-op. To blacklist a fragment, wesimply replace the loop header no-op with a regular no-op. Thus,the interpreter will never again even call into the trace monitor.There is a related problem we have not yet solved, which occurswhen a loop meets all of these conditions:•The VM can form at least one root trace for the loop.•There is at least one hot side exit for which the VM cannotcomplete a trace.•The loop body is short.In this case, the VM will repeatedly pass the loop header, searchfor a trace, find it, execute it, and fall back to the interpreter.With a short loop body, the overhead of finding and calling thetrace is high, and causes performance to be even slower than thebasic interpreter. So far, in this situation we have improved theimplementation so that the VM can complete the branch trace.But it is hard to guarantee that this situation will never happen.As future work, this situation could be avoided by detecting andblacklisting loops for which the average trace call executes fewbytecodes before returning to the interpreter.4.  Nested Trace Tree FormationFigure 7 shows basic trace tree compilation (11) applied to a nestedloop where the inner loop contains two paths. Usually, the innerloop (with header ati2) becomes hot first, and a trace tree is rootedat that point. For example, the first recorded trace may be a cycleTTrunk TraceTree AnchorTrace AnchorBranch TraceGuardSide ExitFigure 5.A tree with two traces, a trunk trace and one branchtrace. The trunk trace contains a guard to which a branch trace wasattached. The branch trace contain a guard that may fail and triggera side exit. Both the trunk and the branch trace loop back to the treeanchor, which is the beginning of the trace tree.Trace 2Trace 1Trace 2Trace 1ClosedLinkedLinkedLinkedNumberNumberStringStringStringStringBooleanTrace 2Trace 1Trace 3LinkedLinkedLinkedClosedNumberNumberNumberBooleanNumberBooleanNumberBoolean(a)(b)(c)Figure 6.We handle type-unstable loops by allowing traces tocompile that cannot loop back to themselves due to a type mis-match. As such traces accumulate, we attempt to connect their loopedges to form groups of trace trees that can execute without havingto side-exit to the interpreter to cover odd type cases. This is par-ticularly important for nested trace trees where an outer tree tries tocall an inner tree (or in this case a forest of inner trees), since innerloops frequently have initially undefined values which change typeto a concrete value after the first iteration.through the inner loop,{i2, i3, i5, α}. Theαsymbol is used toindicate that the trace loops back the tree anchor.When execution leaves the inner loop, the basic design has twochoices. First, the system can stop tracing and give up on compilingthe outer loop, clearly an undesirable solution. The other choice isto continue tracing, compiling traces for the outer loop inside theinner loop’s trace tree.For example, the program might exit ati5and record a branchtrace that incorporates the outer loop:{i5, i7, i1, i6, i7, i1, α}.Later, the program might take the other branch ati2and thenexit, recording another branch trace incorporating the outer loop:{i2, i4, i5, i7, i1, i6, i7, i1, α}. Thus, the outer loop is recorded andcompiled twice, and both copies must be retained in the trace cache.', 'question.', 'question.Representation specialization: objects.In JavaScript, namelookup semantics are complex and potentially expensive becausethey include features like object inheritance andeval. To evaluatean object property read expression likeo.x, the interpreter mustsearch the property map ofoand all of its prototypes and parents.Property maps can be implemented with different data structures(e.g., per-object hash tables or shared hash tables), so the searchprocess also must dispatch on the representation of each objectfound during search. TraceMonkey can simply observe the result ofthe search process and record the simplest possible LIR to accessthe property value. For example, the search might finds the value ofo.xin the prototype ofo, which uses a shared hash-table represen-tation that placesxin slot 2 of a property vector. Then the recordedcan generate LIR that readso.xwith just two or three loads: one toget the prototype, possibly one to get the property value vector, andone more to get slot 2 from the vector. This is a vast simplificationand speedup compared to the original interpreter code. Inheritancerelationships and object representations can change during execu-tion, so the simplified code requires guard instructions that ensurethe object representation is the same. In TraceMonkey, objects’ rep-resentations are assigned an integer key called theobject shape.Thus, the guard is a simple equality check on the object shape.Representation specialization: numbers.JavaScript has nointeger type, only a Number type that is the set of 64-bit IEEE-754 floating-pointer numbers (“doubles”). But many JavaScriptoperators, in particular array accesses and bitwise operators, reallyoperate on integers, so they first convert the number to an integer,and then convert any integer result back to a double.1Clearly, aJavaScript VM that wants to be fast must find a way to operate onintegers directly and avoid these conversions.In TraceMonkey, we support two representations for numbers:integers and doubles. The interpreter uses integer representationsas much as it can, switching for results that can only be representedas doubles. When a trace is started, some values may be importedand represented as integers. Some operations on integers requireguards. For example, adding two integers can produce a value toolarge for the integer representation.Function inlining.LIR traces can cross function boundariesin either direction, achieving function inlining. Move instructionsneed to be recorded for function entry and exit to copy argumentsin and return values out. These move statements are then optimizedaway by the compiler using copy propagation. In order to be ableto return to the interpreter, the trace must also generate LIR torecord that a call frame has been entered and exited. The frameentry and exit LIR saves just enough information to allow theintepreter call stack to be restored later and is much simpler thanthe interpreter’s standard call code. If the function being enteredis not constant (which in JavaScript includes any call by functionname), the recorder must also emit LIR to guard that the functionis the same.Guards and side exits.Each optimization described aboverequires one or more guards to verify the assumptions made indoing the optimization. A guard is just a group of LIR instructionsthat performs a test and conditional exit. The exit branches to aside exit, a small off-trace piece of LIR that returns a pointer toa structure that describes the reason for the exit along with theinterpreter PC at the exit point and any other data needed to restorethe interpreter’s state structures.Aborts.Some constructs are difficult to record in LIR traces.For example,evalor calls to external functions can change theprogram state in unpredictable ways, making it difficult for thetracer to know the current type map in order to continue tracing.A tracing implementation can also have any number of other limi-tations, e.g.,a small-memory device may limit the length of traces.When any situation occurs that prevents the implementation fromcontinuing trace recording, the implementationabortstrace record-ing and returns to the trace monitor.3.2  Trace TreesEspecially simple loops, namely those where control flow, valuetypes, value representations, and inlined functions are all invariant,can be represented by a single trace. But most loops have at leastsome variation, and so the program will take side exits from themain trace. When a side exit becomes hot, TraceMonkey starts anewbranch tracefrom that point and patches the side exit to jumpdirectly to that trace. In this way, a single trace expands on demandto a single-entry, multiple-exittrace tree.This section explains how trace trees are formed during execu-tion. The goal is to form trace trees during execution that cover allthe hot paths of the program.1Arrays are actually worse than this: if the index value is a number, it mustbe converted from a double to a string for the property access operator, andthen to an integer internally to the array implementation.Starting a tree.Tree trees always start at loop headers, becausethey are a natural place to look for hot paths. In TraceMonkey, loopheaders are easy to detect–the bytecode compiler ensures that abytecode is a loop header iff it is the target of a backward branch.TraceMonkey starts a tree when a given loop header has been exe-cuted a certain number of times (2 in the current implementation).Starting a tree just means starting recording a trace for the currentpoint and type map and marking the trace as the root of a tree. Eachtree is associated with a loop header and type map, so there may beseveral trees for a given loop header.Closing the loop.Trace recording can end in several ways.Ideally, the trace reaches the loop header where it started withthe same type map as on entry. This is called atype-stableloopiteration. In this case, the end of the trace can jump right to thebeginning, as all the value representations are exactly as needed toenter the trace. The jump can even skip the usual code that wouldcopy out the state at the end of the trace and copy it back in to thetrace activation record to enter a trace.In certain cases the trace might reach the loop header with adifferent type map. This scenario is sometime observed for the firstiteration of a loop. Some variables inside the loop might initially beundefined, before they are set to a concrete type during the first loopiteration. When recording such an iteration, the recorder cannotlink the trace back to its own loop header since it istype-unstable.Instead, the iteration is terminated with a side exit that will alwaysfail and return to the interpreter. At the same time a new trace isrecorded with the new type map. Every time an additional type-unstable trace is added to a region, its exit type map is compared tothe entry map of all existing traces in case they complement eachother. With this approach we are able to cover type-unstable loopiterations as long they eventually form a stable equilibrium.Finally, the trace might exit the loop before reaching the loopheader, for example because execution reaches abreakorreturnstatement. In this case, the VM simply ends the trace with an exitto the trace monitor.As mentioned previously, we may speculatively chose to rep-resent certain Number-typed values as integers on trace. We do sowhen we observe that Number-typed variables contain an integervalue at trace entry. If during trace recording the variable is unex-pectedly assigned a non-integer value, we have to widen the typeof the variable to a double. As a result, the recorded trace becomesinherently type-unstable since it starts with an integer value butends with a double value. This represents a mis-speculation, sinceat trace entry we specialized the Number-typed value to an integer,assuming that at the loop edge we would again find an integer valuein the variable, allowing us to close the loop. To avoid future spec-ulative failures involving this variable, and to obtain a type-stabletrace we note the fact that the variable in question as been observedto sometimes hold non-integer values in an advisory data structurewhich we call the “oracle”.When compiling loops, we consult the oracle before specializ-ing values to integers. Speculation towards integers is performedonly if no adverse information is known to the oracle about thatparticular variable. Whenever we accidentally compile a loop thatis type-unstable due to mis-speculation of a Number-typed vari-able, we immediately trigger the recording of a new trace, whichbased on the now updated oracle information will start with a dou-ble value and thus become type stable.Extending a tree.Side exits lead to different paths throughthe loop, or paths with different types or representations. Thus, tocompletely cover the loop, the VM must record traces starting at allside exits. These traces are recorded much like root traces: there isa counter for each side exit, and when the counter reaches a hotnessthreshold, recording starts. Recording stops exactly as for the roottrace, using the loop header of the root trace as the target to reach.Our implementation does not extend at all side exits. It extendsonly if the side exit is for a control-flow branch, and only if the sideexit does not leave the loop. In particular we do not want to extenda trace tree along a path that leads to an outer loop, because wewant to cover such paths in an outer tree through treenesting.3.3  BlacklistingSometimes, a program follows a path that cannot be compiledinto a trace, usually because of limitations in the implementation.TraceMonkey does not currently support recording throwing andcatching of arbitrary exceptions. This design trade off was chosen,because exceptions are usually rare in JavaScript. However, if aprogram opts to use exceptions intensively, we would suddenlyincur a punishing runtime overhead if we repeatedly try to recorda trace for this path and repeatedly fail to do so, since we aborttracing every time we observe an exception being thrown.As a result, if a hot loop contains traces that always fail, the VMcould potentially run much more slowly than the base interpreter:the VM repeatedly spends time trying to record traces, but is neverable to run any. To avoid this problem, whenever the VM is aboutto start tracing, it must try to predict whether it will finish the trace.Our prediction algorithm is based onblacklistingtraces thathave been tried and failed. When the VM fails to finish a trace start-ing at a given point, the VM records that a failure has occurred. TheVM also sets a counter so that it will not try to record a trace startingat that point until it is passed a few more times (32 in our imple-mentation). Thisbackoffcounter gives temporary conditions thatprevent tracing a chance to end. For example, a loop may behavedifferently during startup than during its steady-state execution. Af-ter a given number of failures (2 in our implementation), the VMmarks the fragment as blacklisted, which means the VM will neveragain start recording at that point.After implementing this basic strategy, we observed that forsmall loops that get blacklisted, the system can spend a noticeableamount of time just finding the loop fragment and determining thatit has been blacklisted. We now avoid that problem by patching thebytecode. We define an extra no-op bytecode that indicates a loopheader. The VM calls into the trace monitor every time the inter-preter executes a loop header no-op. To blacklist a fragment, wesimply replace the loop header no-op with a regular no-op. Thus,the interpreter will never again even call into the trace monitor.There is a related problem we have not yet solved, which occurswhen a loop meets all of these conditions:•The VM can form at least one root trace for the loop.•There is at least one hot side exit for which the VM cannotcomplete a trace.•The loop body is short.In this case, the VM will repeatedly pass the loop header, searchfor a trace, find it, execute it, and fall back to the interpreter.With a short loop body, the overhead of finding and calling thetrace is high, and causes performance to be even slower than thebasic interpreter. So far, in this situation we have improved theimplementation so that the VM can complete the branch trace.But it is hard to guarantee that this situation will never happen.As future work, this situation could be avoided by detecting andblacklisting loops for which the average trace call executes fewbytecodes before returning to the interpreter.4.  Nested Trace Tree FormationFigure 7 shows basic trace tree compilation (11) applied to a nestedloop where the inner loop contains two paths. Usually, the innerloop (with header ati2) becomes hot first, and a trace tree is rootedat that point. For example, the first recorded trace may be a cycleTTrunk TraceTree AnchorTrace AnchorBranch TraceGuardSide ExitFigure 5.A tree with two traces, a trunk trace and one branchtrace. The trunk trace contains a guard to which a branch trace wasattached. The branch trace contain a guard that may fail and triggera side exit. Both the trunk and the branch trace loop back to the treeanchor, which is the beginning of the trace tree.Trace 2Trace 1Trace 2Trace 1ClosedLinkedLinkedLinkedNumberNumberStringStringStringStringBooleanTrace 2Trace 1Trace 3LinkedLinkedLinkedClosedNumberNumberNumberBooleanNumberBooleanNumberBoolean(a)(b)(c)Figure 6.We handle type-unstable loops by allowing traces tocompile that cannot loop back to themselves due to a type mis-match. As such traces accumulate, we attempt to connect their loopedges to form groups of trace trees that can execute without havingto side-exit to the interpreter to cover odd type cases. This is par-ticularly important for nested trace trees where an outer tree tries tocall an inner tree (or in this case a forest of inner trees), since innerloops frequently have initially undefined values which change typeto a concrete value after the first iteration.through the inner loop,{i2, i3, i5, α}. Theαsymbol is used toindicate that the trace loops back the tree anchor.When execution leaves the inner loop, the basic design has twochoices. First, the system can stop tracing and give up on compilingthe outer loop, clearly an undesirable solution. The other choice isto continue tracing, compiling traces for the outer loop inside theinner loop’s trace tree.For example, the program might exit ati5and record a branchtrace that incorporates the outer loop:{i5, i7, i1, i6, i7, i1, α}.Later, the program might take the other branch ati2and thenexit, recording another branch trace incorporating the outer loop:{i2, i4, i5, i7, i1, i6, i7, i1, α}. Thus, the outer loop is recorded andcompiled twice, and both copies must be retained in the trace cache.', 'Observacion 1', '2017-06-20 12:02:57', 'p', '4', 21, 25),
(11, 'i=2.This is the first iteration of the outer loop. The loop onlines 4-5 becomes hot on its second iteration, so TraceMonkey en-ters recording mode on line 4. In recording mode, TraceMonkeyrecords the code along the trace in a low-level compiler intermedi-ate representation we callLIR. The LIR trace encodes all the oper-ations performed and the types of all operands. The LIR trace alsoencodesguards, which are checks that verify that the control flowand types are identical to those observed during trace recording.Thus, on later executions, if and only if all guards are passed, thetrace has the required program semantics.', 'i=2.', 'i=2.This is the first iteration of the outer loop. The loop onlines 4-5 becomes hot on its second iteration, so TraceMonkey en-ters recording mode on line 4. In recording mode, TraceMonkeyrecords the code along the trace in a low-level compiler intermedi-ate representation we callLIR. The LIR trace encodes all the oper-ations performed and the types of all operands. The LIR trace alsoencodesguards, which are checks that verify that the control flowand types are identical to those observed during trace recording.Thus, on later executions, if and only if all guards are passed, thetrace has the required program semantics.', 'Observacion 2', '2017-06-20 12:03:16', 'p', '3', 21, 25);

-- --------------------------------------------------------

--
-- Estructura de tabla para la tabla `Project`
--

CREATE TABLE `Project` (
  `id` int(11) NOT NULL,
  `name` varchar(75) COLLATE utf8_spanish_ci DEFAULT NULL,
  `modality` varchar(35) COLLATE utf8_spanish_ci DEFAULT NULL,
  `gestion` varchar(7) COLLATE utf8_spanish_ci DEFAULT NULL,
  `hito` varchar(25) COLLATE utf8_spanish_ci DEFAULT 'Pendiente',
  `register_date` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `id_student` int(11) DEFAULT NULL,
  `id_teacher` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_spanish_ci;

--
-- Volcado de datos para la tabla `Project`
--

INSERT INTO `Project` (`id`, `name`, `modality`, `gestion`, `hito`, `register_date`, `id_student`, `id_teacher`) VALUES
(5, 'Sistema de diseño de losas', 'Proyecto de grado', '1/2017', 'Pendiente', '2017-06-19 13:53:20', 14, 21),
(6, 'Sistema de diseño de losas', 'Proyecto de grado', '1/2017', 'Pendiente', '2017-06-19 14:54:34', 18, 22),
(18, 'Sistema de diseño de losas', 'Proyecto de grado', '1/2017', 'Pendiente', '2017-06-19 13:53:20', 14, 22);

-- --------------------------------------------------------

--
-- Estructura de tabla para la tabla `Student`
--

CREATE TABLE `Student` (
  `id` int(11) NOT NULL,
  `cu` varchar(7) COLLATE utf8_spanish_ci DEFAULT NULL,
  `college_carrer` varchar(55) COLLATE utf8_spanish_ci DEFAULT NULL,
  `status` bit(1) NOT NULL,
  `id_client` int(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_spanish_ci;

--
-- Volcado de datos para la tabla `Student`
--

INSERT INTO `Student` (`id`, `cu`, `college_carrer`, `status`, `id_client`) VALUES
(14, '35-1111', 'Ingeniera de Sistemas', b'0', 40),
(15, '34-3536', 'IngTelecomunicaciones', b'0', 41),
(16, '35-2222', 'Ingeniería de sistemas', b'0', 42),
(17, '35-3333', 'Ingeniería de sistemas', b'0', 43),
(18, '35-4444', 'Ingeniería de sistemas', b'0', 44);

-- --------------------------------------------------------

--
-- Estructura de tabla para la tabla `Teacher`
--

CREATE TABLE `Teacher` (
  `id` int(11) NOT NULL,
  `profession` varchar(50) COLLATE utf8_spanish_ci DEFAULT NULL,
  `id_client` int(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_spanish_ci;

--
-- Volcado de datos para la tabla `Teacher`
--

INSERT INTO `Teacher` (`id`, `profession`, `id_client`) VALUES
(21, 'Ingeniero de Sistemas', 39),
(22, 'Ingeniero de Sistemas', 45);

--
-- Índices para tablas volcadas
--

--
-- Indices de la tabla `Client`
--
ALTER TABLE `Client`
  ADD PRIMARY KEY (`id`);

--
-- Indices de la tabla `Document`
--
ALTER TABLE `Document`
  ADD PRIMARY KEY (`id`),
  ADD KEY `id_project` (`id_project`);

--
-- Indices de la tabla `Observation`
--
ALTER TABLE `Observation`
  ADD PRIMARY KEY (`id`),
  ADD KEY `id_teacher` (`id_teacher`),
  ADD KEY `id_document` (`id_document`);

--
-- Indices de la tabla `Project`
--
ALTER TABLE `Project`
  ADD PRIMARY KEY (`id`),
  ADD KEY `id_student` (`id_student`);

--
-- Indices de la tabla `Student`
--
ALTER TABLE `Student`
  ADD PRIMARY KEY (`id`),
  ADD KEY `id_user` (`id_client`);

--
-- Indices de la tabla `Teacher`
--
ALTER TABLE `Teacher`
  ADD PRIMARY KEY (`id`),
  ADD KEY `id_user` (`id_client`);

--
-- AUTO_INCREMENT de las tablas volcadas
--

--
-- AUTO_INCREMENT de la tabla `Client`
--
ALTER TABLE `Client`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=46;
--
-- AUTO_INCREMENT de la tabla `Document`
--
ALTER TABLE `Document`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=27;
--
-- AUTO_INCREMENT de la tabla `Observation`
--
ALTER TABLE `Observation`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=12;
--
-- AUTO_INCREMENT de la tabla `Project`
--
ALTER TABLE `Project`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=19;
--
-- AUTO_INCREMENT de la tabla `Student`
--
ALTER TABLE `Student`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=19;
--
-- AUTO_INCREMENT de la tabla `Teacher`
--
ALTER TABLE `Teacher`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=23;
--
-- Restricciones para tablas volcadas
--

--
-- Filtros para la tabla `Observation`
--
ALTER TABLE `Observation`
  ADD CONSTRAINT `Observation_ibfk_1` FOREIGN KEY (`id_teacher`) REFERENCES `Teacher` (`id`),
  ADD CONSTRAINT `Observation_ibfk_2` FOREIGN KEY (`id_document`) REFERENCES `Document` (`id`);

--
-- Filtros para la tabla `Student`
--
ALTER TABLE `Student`
  ADD CONSTRAINT `Student_ibfk_1` FOREIGN KEY (`id_client`) REFERENCES `Client` (`id`);

--
-- Filtros para la tabla `Teacher`
--
ALTER TABLE `Teacher`
  ADD CONSTRAINT `Teacher_ibfk_1` FOREIGN KEY (`id_client`) REFERENCES `Client` (`id`);

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
